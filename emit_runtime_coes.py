#!/usr/bin/env python3
"""
Emit final runtime COEs and a simple FPGA memory map for Stage-2 deliverable.

Actions:
 - Collect key COEs from `COE results` and copy them into `COE results/final_coes`
 - Normalize filenames and report entry counts and word widths
 - Produce `COE results/final_coes/memory_map.txt` with recommended placement and sizes

This is a helper for FPGA integration; addresses are logical and for guidance.
"""
import os
import shutil

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
COE_DIR = os.path.join(SCRIPT_DIR, 'COE results')
OUT_DIR = os.path.join(COE_DIR, 'final_coes')
os.makedirs(OUT_DIR, exist_ok=True)

FILES_TO_COLLECT = [
    ('geometry32.coe','geometry32.coe',32),
    ('framebuffer.coe','framebuffer.coe',16),
    ('lights_runtime_multi.coe','lights.coe',16),
    ('vehicles_counts_full.coe','counts.coe',16),
    ('vehicle_ambulance_path.coe','ambulance_path.coe',32),
]

# also include any ambulance runtime COEs
for name in os.listdir(COE_DIR):
    if name.startswith('ambulance_runtime') and name.endswith('.coe'):
        FILES_TO_COLLECT.append((name,name,32))

def parse_coe_count(path):
    with open(path,'r',encoding='utf-8') as f:
        text = f.read()
    for ch in [';', '\n', '\r']:
        text = text.replace(ch, ',')
    toks = [t.strip() for t in text.split(',') if t.strip()]
    vals = []
    for t in toks:
        if t.lower().startswith('memory_initialization'): continue
        tt = t
        if tt.lower().startswith('0x'): tt = tt[2:]
        if all(c in '0123456789abcdefABCDEF' for c in tt):
            vals.append(tt)
    return len(vals)

report_lines = []
report_lines.append('FPGA Memory Map - generated by emit_runtime_coes.py')
report_lines.append('Directory: final_coes')
report_lines.append('')

addr_cursor = 0
for src_name, dst_name, width in FILES_TO_COLLECT:
    src = os.path.join(COE_DIR, src_name)
    if not os.path.exists(src):
        report_lines.append(f'MISSING: {src_name} (skipped)')
        continue
    dst = os.path.join(OUT_DIR, dst_name)
    shutil.copy2(src, dst)
    entries = parse_coe_count(dst)
    # logical address in words (per 32-bit word unit)
    if width == 32:
        words = entries
    else:
        # convert 16-bit entries to 32-bit word-equivalents for addressing guidance
        words = (entries + 1) // 2
    report_lines.append(f'{dst_name}: words={words} (entries={entries}, width={width} bits), recommended_addr=0x{addr_cursor:08X}')
    # advance cursor by words
    addr_cursor += words

# estimate BRAM usage (Xilinx 18Kb per BRAM ~ 18*1024 bits)
report_lines.append('')
report_lines.append('BRAM estimate (rough):')
for src_name, dst_name, width in FILES_TO_COLLECT:
    dst = os.path.join(OUT_DIR, dst_name)
    if not os.path.exists(dst): continue
    entries = parse_coe_count(dst)
    bits = entries * width
    bram_kbits = 18
    brams = max(1, int((bits + (bram_kbits*1024)-1) // (bram_kbits*1024)))
    report_lines.append(f'{dst_name}: {bits} bits -> ~{brams} x 18Kb BRAM')

map_path = os.path.join(OUT_DIR, 'memory_map.txt')
with open(map_path,'w',encoding='utf-8') as f:
    f.write('\n'.join(report_lines))

print('Final COEs collected to', OUT_DIR)
print('Memory map written to', map_path)
